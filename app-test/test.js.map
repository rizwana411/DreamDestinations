{"version":3,"sources":["/app/test.js","/bower_components/angular-mocks/angular-mocks.js","angular-mocks (bower component)"],"names":["require"],"mappings":";;;;AAAA;;AAAA,oBAAAA,CAAQ;AACR,oBAAAA,CAAQ,G;;;;;;;;ACDR;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA,6DAA4D,2BAA2B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA8B;AAC9B;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA2B,8DAA8D;AACzF,2CAA0C,yBAAyB;AACnE;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ,uCAAuC;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,2CAA0C,2BAA2B;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B,2BAA2B;AACtD,gBAAe,iEAAiE;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,iCAAgC,aAAa,EAAE;AAC/C,iCAAgC,aAAa,qBAAqB,EAAE;AACpE,iCAAgC,aAAa,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,SAAQ;AACR,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA,qBAAoB,4CAA4C;AAChE,WAAU,gCAAgC;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,4BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,8CAA8C,EAAE;AACvE,yBAAwB,+CAA+C,EAAE;AACzE,yBAAwB,+CAA+C,EAAE;AACzE,0BAAyB,gDAAgD,EAAE;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,0BAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,uDAAuD;AAC/D;AACA;AACA;AACA,YAAW,WAAW;AACtB,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA,YAAW,SAAS;AACpB,mCAAkC,wCAAwC;AAC1E,YAAW,MAAM;AACjB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,sCAAqC,iCAAiC;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,iCAAiC;AACxE;AACA;AACA;;AAEA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA,6BAA4B,EAAE,4DAA4D,EAAE;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gCAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE,iBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,sDAAsD;AAClG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI,6BAA6B;AACjC;AACA;AACA;AACA,4BAA2B,mDAAmD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,sBAAqB;AACrB;;AAEA,2CAA0C,mBAAmB;AAC7D;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA0C,gBAAgB,GAAG,iBAAiB;;AAE9E;AACA;AACA;AACA;;AAEA;AACA,gDAA+C,uBAAuB;AACtE;AACA,SAAQ;;;AAGR;AACA;AACA;AACA,SAAQ;;;AAGR;AACA;AACA;AACA;AACA,SAAQ;;;AAGR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAQ;;;AAGR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;;;AAGR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;;AAEV;AACA;AACA,SAAQ;AACR,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD,SAAQ;AACR;AACA;AACA;AACA,4DAA2D;AAC3D,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAwC,mBAAmB;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA2D;AAC3D;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,+BAA+B;AAC5C;AACA,cAAa,kCAAkC;AAC/C;AACA,cAAa,2BAA2B;AACxC;AACA,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,2BAA2B;AACxC,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,2BAA2B;AACxC,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,2BAA2B;AACxC,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,kCAAkC;AAC/C;AACA,cAAa,2BAA2B;AACxC,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,kCAAkC;AAC/C;AACA,cAAa,2BAA2B;AACxC,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,kCAAkC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,+BAA+B;AAC5C;AACA,cAAa,yCAAyC;AACtD;AACA;AACA,cAAa,2BAA2B;AACxC;AACA,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,yCAAyC;AACtD;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,yCAAyC;AACtD;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,yCAAyC;AACtD;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,+BAA+B;AAC5C;AACA,cAAa,SAAS;AACtB,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,iDAAgD,2BAA2B;AAC3E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,kDAAkD;AACtE,MAAK;;AAEL;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,qBAAqB;AACzC,wCAAuC,qDAAqD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,mBAAmB,GAAG,GAAG,qBAAqB;AACtG;AACA;AACA,OAAM;AACN,KAAI;AACJ;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA,YAAW,QAAQ;AACnB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,8CAA8C;AACtD;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA,KAAI,yDAAyD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,eAAe,GAAG,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,SAAQ;AACR,6DAA4D;AAC5D;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA,WAAU;AACV;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,uBAAsB,eAAe,GAAG,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,SAAQ;AACR,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,+BAA+B;AAC1C;AACA,YAAW,iBAAiB;AAC5B,YAAW,2BAA2B;AACtC;AACA,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAsB,WAAW;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,+BAA+B;AAC1C;AACA,YAAW,2BAA2B;AACtC,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,+BAA+B;AAC1C;AACA,YAAW,2BAA2B;AACtC,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,+BAA+B;AAC1C;AACA,YAAW,2BAA2B;AACtC,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,+BAA+B;AAC1C;AACA,YAAW,iBAAiB;AAC5B,YAAW,2BAA2B;AACtC,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,+BAA+B;AAC1C;AACA,YAAW,iBAAiB;AAC5B,YAAW,2BAA2B;AACtC,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,+BAA+B;AAC1C;AACA,YAAW,iBAAiB;AAC5B,YAAW,2BAA2B;AACtC,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,+BAA+B;AAC1C;AACA,YAAW,SAAS;AACpB,OAAM,4CAA4C;AAClD,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAI,gCAAgC;AACpC,gDAA+C,gCAAgC;AAC/E;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA,8DAA6D;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,iCAAiC;AAC1F;AACA,WAAU,iCAAiC;AAC3C;AACA,cAAa,4BAA4B;AACzC;AACA;AACA;AACA,cAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,cAAa;AACb,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,SAAQ;AACR;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD;AACrD,aAAY;AACZ;AACA;AACA;AACA,aAAY;AACZ,WAAU;AACV,SAAQ;AACR;AACA;AACA;AACA,cAAa,YAAY;AACzB;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,4CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;AAGD,EAAC;;;;;;;ACrjGD,yC","file":"test.js","sourcesContent":["require('angular');\nrequire('angular-mocks');\n\n\n/** WEBPACK FOOTER **\n ** ./app/test.js\n **/","/**\r\n * @license AngularJS v1.5.8\r\n * (c) 2010-2016 Google, Inc. http://angularjs.org\r\n * License: MIT\r\n */\r\n(function(window, angular) {\r\n\r\n'use strict';\r\n\r\n/**\r\n * @ngdoc object\r\n * @name angular.mock\r\n * @description\r\n *\r\n * Namespace from 'angular-mocks.js' which contains testing related code.\r\n *\r\n */\r\nangular.mock = {};\r\n\r\n/**\r\n * ! This is a private undocumented service !\r\n *\r\n * @name $browser\r\n *\r\n * @description\r\n * This service is a mock implementation of {@link ng.$browser}. It provides fake\r\n * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,\r\n * cookies, etc.\r\n *\r\n * The api of this service is the same as that of the real {@link ng.$browser $browser}, except\r\n * that there are several helper methods available which can be used in tests.\r\n */\r\nangular.mock.$BrowserProvider = function() {\r\n  this.$get = function() {\r\n    return new angular.mock.$Browser();\r\n  };\r\n};\r\n\r\nangular.mock.$Browser = function() {\r\n  var self = this;\r\n\r\n  this.isMock = true;\r\n  self.$$url = \"http://server/\";\r\n  self.$$lastUrl = self.$$url; // used by url polling fn\r\n  self.pollFns = [];\r\n\r\n  // TODO(vojta): remove this temporary api\r\n  self.$$completeOutstandingRequest = angular.noop;\r\n  self.$$incOutstandingRequestCount = angular.noop;\r\n\r\n\r\n  // register url polling fn\r\n\r\n  self.onUrlChange = function(listener) {\r\n    self.pollFns.push(\r\n      function() {\r\n        if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {\r\n          self.$$lastUrl = self.$$url;\r\n          self.$$lastState = self.$$state;\r\n          listener(self.$$url, self.$$state);\r\n        }\r\n      }\r\n    );\r\n\r\n    return listener;\r\n  };\r\n\r\n  self.$$applicationDestroyed = angular.noop;\r\n  self.$$checkUrlChange = angular.noop;\r\n\r\n  self.deferredFns = [];\r\n  self.deferredNextId = 0;\r\n\r\n  self.defer = function(fn, delay) {\r\n    delay = delay || 0;\r\n    self.deferredFns.push({time:(self.defer.now + delay), fn:fn, id: self.deferredNextId});\r\n    self.deferredFns.sort(function(a, b) { return a.time - b.time;});\r\n    return self.deferredNextId++;\r\n  };\r\n\r\n\r\n  /**\r\n   * @name $browser#defer.now\r\n   *\r\n   * @description\r\n   * Current milliseconds mock time.\r\n   */\r\n  self.defer.now = 0;\r\n\r\n\r\n  self.defer.cancel = function(deferId) {\r\n    var fnIndex;\r\n\r\n    angular.forEach(self.deferredFns, function(fn, index) {\r\n      if (fn.id === deferId) fnIndex = index;\r\n    });\r\n\r\n    if (angular.isDefined(fnIndex)) {\r\n      self.deferredFns.splice(fnIndex, 1);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n\r\n  /**\r\n   * @name $browser#defer.flush\r\n   *\r\n   * @description\r\n   * Flushes all pending requests and executes the defer callbacks.\r\n   *\r\n   * @param {number=} number of milliseconds to flush. See {@link #defer.now}\r\n   */\r\n  self.defer.flush = function(delay) {\r\n    var nextTime;\r\n\r\n    if (angular.isDefined(delay)) {\r\n      // A delay was passed so compute the next time\r\n      nextTime = self.defer.now + delay;\r\n    } else {\r\n      if (self.deferredFns.length) {\r\n        // No delay was passed so set the next time so that it clears the deferred queue\r\n        nextTime = self.deferredFns[self.deferredFns.length - 1].time;\r\n      } else {\r\n        // No delay passed, but there are no deferred tasks so flush - indicates an error!\r\n        throw new Error('No deferred tasks to be flushed');\r\n      }\r\n    }\r\n\r\n    while (self.deferredFns.length && self.deferredFns[0].time <= nextTime) {\r\n      // Increment the time and call the next deferred function\r\n      self.defer.now = self.deferredFns[0].time;\r\n      self.deferredFns.shift().fn();\r\n    }\r\n\r\n    // Ensure that the current time is correct\r\n    self.defer.now = nextTime;\r\n  };\r\n\r\n  self.$$baseHref = '/';\r\n  self.baseHref = function() {\r\n    return this.$$baseHref;\r\n  };\r\n};\r\nangular.mock.$Browser.prototype = {\r\n\r\n  /**\r\n   * @name $browser#poll\r\n   *\r\n   * @description\r\n   * run all fns in pollFns\r\n   */\r\n  poll: function poll() {\r\n    angular.forEach(this.pollFns, function(pollFn) {\r\n      pollFn();\r\n    });\r\n  },\r\n\r\n  url: function(url, replace, state) {\r\n    if (angular.isUndefined(state)) {\r\n      state = null;\r\n    }\r\n    if (url) {\r\n      this.$$url = url;\r\n      // Native pushState serializes & copies the object; simulate it.\r\n      this.$$state = angular.copy(state);\r\n      return this;\r\n    }\r\n\r\n    return this.$$url;\r\n  },\r\n\r\n  state: function() {\r\n    return this.$$state;\r\n  },\r\n\r\n  notifyWhenNoOutstandingRequests: function(fn) {\r\n    fn();\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc provider\r\n * @name $exceptionHandlerProvider\r\n *\r\n * @description\r\n * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors\r\n * passed to the `$exceptionHandler`.\r\n */\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $exceptionHandler\r\n *\r\n * @description\r\n * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed\r\n * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration\r\n * information.\r\n *\r\n *\r\n * ```js\r\n *   describe('$exceptionHandlerProvider', function() {\r\n *\r\n *     it('should capture log messages and exceptions', function() {\r\n *\r\n *       module(function($exceptionHandlerProvider) {\r\n *         $exceptionHandlerProvider.mode('log');\r\n *       });\r\n *\r\n *       inject(function($log, $exceptionHandler, $timeout) {\r\n *         $timeout(function() { $log.log(1); });\r\n *         $timeout(function() { $log.log(2); throw 'banana peel'; });\r\n *         $timeout(function() { $log.log(3); });\r\n *         expect($exceptionHandler.errors).toEqual([]);\r\n *         expect($log.assertEmpty());\r\n *         $timeout.flush();\r\n *         expect($exceptionHandler.errors).toEqual(['banana peel']);\r\n *         expect($log.log.logs).toEqual([[1], [2], [3]]);\r\n *       });\r\n *     });\r\n *   });\r\n * ```\r\n */\r\n\r\nangular.mock.$ExceptionHandlerProvider = function() {\r\n  var handler;\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $exceptionHandlerProvider#mode\r\n   *\r\n   * @description\r\n   * Sets the logging mode.\r\n   *\r\n   * @param {string} mode Mode of operation, defaults to `rethrow`.\r\n   *\r\n   *   - `log`: Sometimes it is desirable to test that an error is thrown, for this case the `log`\r\n   *     mode stores an array of errors in `$exceptionHandler.errors`, to allow later assertion of\r\n   *     them. See {@link ngMock.$log#assertEmpty assertEmpty()} and\r\n   *     {@link ngMock.$log#reset reset()}.\r\n   *   - `rethrow`: If any errors are passed to the handler in tests, it typically means that there\r\n   *     is a bug in the application or test, so this mock will make these tests fail. For any\r\n   *     implementations that expect exceptions to be thrown, the `rethrow` mode will also maintain\r\n   *     a log of thrown errors in `$exceptionHandler.errors`.\r\n   */\r\n  this.mode = function(mode) {\r\n\r\n    switch (mode) {\r\n      case 'log':\r\n      case 'rethrow':\r\n        var errors = [];\r\n        handler = function(e) {\r\n          if (arguments.length == 1) {\r\n            errors.push(e);\r\n          } else {\r\n            errors.push([].slice.call(arguments, 0));\r\n          }\r\n          if (mode === \"rethrow\") {\r\n            throw e;\r\n          }\r\n        };\r\n        handler.errors = errors;\r\n        break;\r\n      default:\r\n        throw new Error(\"Unknown mode '\" + mode + \"', only 'log'/'rethrow' modes are allowed!\");\r\n    }\r\n  };\r\n\r\n  this.$get = function() {\r\n    return handler;\r\n  };\r\n\r\n  this.mode('rethrow');\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $log\r\n *\r\n * @description\r\n * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays\r\n * (one array per logging level). These arrays are exposed as `logs` property of each of the\r\n * level-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.\r\n *\r\n */\r\nangular.mock.$LogProvider = function() {\r\n  var debug = true;\r\n\r\n  function concat(array1, array2, index) {\r\n    return array1.concat(Array.prototype.slice.call(array2, index));\r\n  }\r\n\r\n  this.debugEnabled = function(flag) {\r\n    if (angular.isDefined(flag)) {\r\n      debug = flag;\r\n      return this;\r\n    } else {\r\n      return debug;\r\n    }\r\n  };\r\n\r\n  this.$get = function() {\r\n    var $log = {\r\n      log: function() { $log.log.logs.push(concat([], arguments, 0)); },\r\n      warn: function() { $log.warn.logs.push(concat([], arguments, 0)); },\r\n      info: function() { $log.info.logs.push(concat([], arguments, 0)); },\r\n      error: function() { $log.error.logs.push(concat([], arguments, 0)); },\r\n      debug: function() {\r\n        if (debug) {\r\n          $log.debug.logs.push(concat([], arguments, 0));\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name $log#reset\r\n     *\r\n     * @description\r\n     * Reset all of the logging arrays to empty.\r\n     */\r\n    $log.reset = function() {\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#log.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#log `log()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.log('Some Log');\r\n       * var first = $log.log.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.log.logs = [];\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#info.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#info `info()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.info('Some Info');\r\n       * var first = $log.info.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.info.logs = [];\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#warn.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#warn `warn()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.warn('Some Warning');\r\n       * var first = $log.warn.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.warn.logs = [];\r\n      /**\r\n       * @ngdoc property\r\n       * @name $log#error.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#error `error()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.error('Some Error');\r\n       * var first = $log.error.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.error.logs = [];\r\n        /**\r\n       * @ngdoc property\r\n       * @name $log#debug.logs\r\n       *\r\n       * @description\r\n       * Array of messages logged using {@link ng.$log#debug `debug()`}.\r\n       *\r\n       * @example\r\n       * ```js\r\n       * $log.debug('Some Error');\r\n       * var first = $log.debug.logs.unshift();\r\n       * ```\r\n       */\r\n      $log.debug.logs = [];\r\n    };\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name $log#assertEmpty\r\n     *\r\n     * @description\r\n     * Assert that all of the logging methods have no logged messages. If any messages are present,\r\n     * an exception is thrown.\r\n     */\r\n    $log.assertEmpty = function() {\r\n      var errors = [];\r\n      angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {\r\n        angular.forEach($log[logLevel].logs, function(log) {\r\n          angular.forEach(log, function(logItem) {\r\n            errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\\n' +\r\n                        (logItem.stack || ''));\r\n          });\r\n        });\r\n      });\r\n      if (errors.length) {\r\n        errors.unshift(\"Expected $log to be empty! Either a message was logged unexpectedly, or \" +\r\n          \"an expected log message was not checked and removed:\");\r\n        errors.push('');\r\n        throw new Error(errors.join('\\n---------\\n'));\r\n      }\r\n    };\r\n\r\n    $log.reset();\r\n    return $log;\r\n  };\r\n};\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $interval\r\n *\r\n * @description\r\n * Mock implementation of the $interval service.\r\n *\r\n * Use {@link ngMock.$interval#flush `$interval.flush(millis)`} to\r\n * move forward by `millis` milliseconds and trigger any functions scheduled to run in that\r\n * time.\r\n *\r\n * @param {function()} fn A function that should be called repeatedly.\r\n * @param {number} delay Number of milliseconds between each function call.\r\n * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat\r\n *   indefinitely.\r\n * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise\r\n *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.\r\n * @param {...*=} Pass additional parameters to the executed function.\r\n * @returns {promise} A promise which will be notified on each iteration.\r\n */\r\nangular.mock.$IntervalProvider = function() {\r\n  this.$get = ['$browser', '$rootScope', '$q', '$$q',\r\n       function($browser,   $rootScope,   $q,   $$q) {\r\n    var repeatFns = [],\r\n        nextRepeatId = 0,\r\n        now = 0;\r\n\r\n    var $interval = function(fn, delay, count, invokeApply) {\r\n      var hasParams = arguments.length > 4,\r\n          args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],\r\n          iteration = 0,\r\n          skipApply = (angular.isDefined(invokeApply) && !invokeApply),\r\n          deferred = (skipApply ? $$q : $q).defer(),\r\n          promise = deferred.promise;\r\n\r\n      count = (angular.isDefined(count)) ? count : 0;\r\n      promise.then(null, null, (!hasParams) ? fn : function() {\r\n        fn.apply(null, args);\r\n      });\r\n\r\n      promise.$$intervalId = nextRepeatId;\r\n\r\n      function tick() {\r\n        deferred.notify(iteration++);\r\n\r\n        if (count > 0 && iteration >= count) {\r\n          var fnIndex;\r\n          deferred.resolve(iteration);\r\n\r\n          angular.forEach(repeatFns, function(fn, index) {\r\n            if (fn.id === promise.$$intervalId) fnIndex = index;\r\n          });\r\n\r\n          if (angular.isDefined(fnIndex)) {\r\n            repeatFns.splice(fnIndex, 1);\r\n          }\r\n        }\r\n\r\n        if (skipApply) {\r\n          $browser.defer.flush();\r\n        } else {\r\n          $rootScope.$apply();\r\n        }\r\n      }\r\n\r\n      repeatFns.push({\r\n        nextTime:(now + delay),\r\n        delay: delay,\r\n        fn: tick,\r\n        id: nextRepeatId,\r\n        deferred: deferred\r\n      });\r\n      repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\r\n\r\n      nextRepeatId++;\r\n      return promise;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name $interval#cancel\r\n     *\r\n     * @description\r\n     * Cancels a task associated with the `promise`.\r\n     *\r\n     * @param {promise} promise A promise from calling the `$interval` function.\r\n     * @returns {boolean} Returns `true` if the task was successfully cancelled.\r\n     */\r\n    $interval.cancel = function(promise) {\r\n      if (!promise) return false;\r\n      var fnIndex;\r\n\r\n      angular.forEach(repeatFns, function(fn, index) {\r\n        if (fn.id === promise.$$intervalId) fnIndex = index;\r\n      });\r\n\r\n      if (angular.isDefined(fnIndex)) {\r\n        repeatFns[fnIndex].deferred.reject('canceled');\r\n        repeatFns.splice(fnIndex, 1);\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name $interval#flush\r\n     * @description\r\n     *\r\n     * Runs interval tasks scheduled to be run in the next `millis` milliseconds.\r\n     *\r\n     * @param {number=} millis maximum timeout amount to flush up until.\r\n     *\r\n     * @return {number} The amount of time moved forward.\r\n     */\r\n    $interval.flush = function(millis) {\r\n      now += millis;\r\n      while (repeatFns.length && repeatFns[0].nextTime <= now) {\r\n        var task = repeatFns[0];\r\n        task.fn();\r\n        task.nextTime += task.delay;\r\n        repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\r\n      }\r\n      return millis;\r\n    };\r\n\r\n    return $interval;\r\n  }];\r\n};\r\n\r\n\r\n/* jshint -W101 */\r\n/* The R_ISO8061_STR regex is never going to fit into the 100 char limit!\r\n * This directive should go inside the anonymous function but a bug in JSHint means that it would\r\n * not be enacted early enough to prevent the warning.\r\n */\r\nvar R_ISO8061_STR = /^(-?\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?:\\:?(\\d\\d)(?:\\:?(\\d\\d)(?:\\.(\\d{3}))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d)))?$/;\r\n\r\nfunction jsonStringToDate(string) {\r\n  var match;\r\n  if (match = string.match(R_ISO8061_STR)) {\r\n    var date = new Date(0),\r\n        tzHour = 0,\r\n        tzMin  = 0;\r\n    if (match[9]) {\r\n      tzHour = toInt(match[9] + match[10]);\r\n      tzMin = toInt(match[9] + match[11]);\r\n    }\r\n    date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));\r\n    date.setUTCHours(toInt(match[4] || 0) - tzHour,\r\n                     toInt(match[5] || 0) - tzMin,\r\n                     toInt(match[6] || 0),\r\n                     toInt(match[7] || 0));\r\n    return date;\r\n  }\r\n  return string;\r\n}\r\n\r\nfunction toInt(str) {\r\n  return parseInt(str, 10);\r\n}\r\n\r\nfunction padNumberInMock(num, digits, trim) {\r\n  var neg = '';\r\n  if (num < 0) {\r\n    neg =  '-';\r\n    num = -num;\r\n  }\r\n  num = '' + num;\r\n  while (num.length < digits) num = '0' + num;\r\n  if (trim) {\r\n    num = num.substr(num.length - digits);\r\n  }\r\n  return neg + num;\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc type\r\n * @name angular.mock.TzDate\r\n * @description\r\n *\r\n * *NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.\r\n *\r\n * Mock of the Date type which has its timezone specified via constructor arg.\r\n *\r\n * The main purpose is to create Date-like instances with timezone fixed to the specified timezone\r\n * offset, so that we can test code that depends on local timezone settings without dependency on\r\n * the time zone settings of the machine where the code is running.\r\n *\r\n * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)\r\n * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*\r\n *\r\n * @example\r\n * !!!! WARNING !!!!!\r\n * This is not a complete Date object so only methods that were implemented can be called safely.\r\n * To make matters worse, TzDate instances inherit stuff from Date via a prototype.\r\n *\r\n * We do our best to intercept calls to \"unimplemented\" methods, but since the list of methods is\r\n * incomplete we might be missing some non-standard methods. This can result in errors like:\r\n * \"Date.prototype.foo called on incompatible Object\".\r\n *\r\n * ```js\r\n * var newYearInBratislava = new TzDate(-1, '2009-12-31T23:00:00Z');\r\n * newYearInBratislava.getTimezoneOffset() => -60;\r\n * newYearInBratislava.getFullYear() => 2010;\r\n * newYearInBratislava.getMonth() => 0;\r\n * newYearInBratislava.getDate() => 1;\r\n * newYearInBratislava.getHours() => 0;\r\n * newYearInBratislava.getMinutes() => 0;\r\n * newYearInBratislava.getSeconds() => 0;\r\n * ```\r\n *\r\n */\r\nangular.mock.TzDate = function(offset, timestamp) {\r\n  var self = new Date(0);\r\n  if (angular.isString(timestamp)) {\r\n    var tsStr = timestamp;\r\n\r\n    self.origDate = jsonStringToDate(timestamp);\r\n\r\n    timestamp = self.origDate.getTime();\r\n    if (isNaN(timestamp)) {\r\n      throw {\r\n        name: \"Illegal Argument\",\r\n        message: \"Arg '\" + tsStr + \"' passed into TzDate constructor is not a valid date string\"\r\n      };\r\n    }\r\n  } else {\r\n    self.origDate = new Date(timestamp);\r\n  }\r\n\r\n  var localOffset = new Date(timestamp).getTimezoneOffset();\r\n  self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;\r\n  self.date = new Date(timestamp + self.offsetDiff);\r\n\r\n  self.getTime = function() {\r\n    return self.date.getTime() - self.offsetDiff;\r\n  };\r\n\r\n  self.toLocaleDateString = function() {\r\n    return self.date.toLocaleDateString();\r\n  };\r\n\r\n  self.getFullYear = function() {\r\n    return self.date.getFullYear();\r\n  };\r\n\r\n  self.getMonth = function() {\r\n    return self.date.getMonth();\r\n  };\r\n\r\n  self.getDate = function() {\r\n    return self.date.getDate();\r\n  };\r\n\r\n  self.getHours = function() {\r\n    return self.date.getHours();\r\n  };\r\n\r\n  self.getMinutes = function() {\r\n    return self.date.getMinutes();\r\n  };\r\n\r\n  self.getSeconds = function() {\r\n    return self.date.getSeconds();\r\n  };\r\n\r\n  self.getMilliseconds = function() {\r\n    return self.date.getMilliseconds();\r\n  };\r\n\r\n  self.getTimezoneOffset = function() {\r\n    return offset * 60;\r\n  };\r\n\r\n  self.getUTCFullYear = function() {\r\n    return self.origDate.getUTCFullYear();\r\n  };\r\n\r\n  self.getUTCMonth = function() {\r\n    return self.origDate.getUTCMonth();\r\n  };\r\n\r\n  self.getUTCDate = function() {\r\n    return self.origDate.getUTCDate();\r\n  };\r\n\r\n  self.getUTCHours = function() {\r\n    return self.origDate.getUTCHours();\r\n  };\r\n\r\n  self.getUTCMinutes = function() {\r\n    return self.origDate.getUTCMinutes();\r\n  };\r\n\r\n  self.getUTCSeconds = function() {\r\n    return self.origDate.getUTCSeconds();\r\n  };\r\n\r\n  self.getUTCMilliseconds = function() {\r\n    return self.origDate.getUTCMilliseconds();\r\n  };\r\n\r\n  self.getDay = function() {\r\n    return self.date.getDay();\r\n  };\r\n\r\n  // provide this method only on browsers that already have it\r\n  if (self.toISOString) {\r\n    self.toISOString = function() {\r\n      return padNumberInMock(self.origDate.getUTCFullYear(), 4) + '-' +\r\n            padNumberInMock(self.origDate.getUTCMonth() + 1, 2) + '-' +\r\n            padNumberInMock(self.origDate.getUTCDate(), 2) + 'T' +\r\n            padNumberInMock(self.origDate.getUTCHours(), 2) + ':' +\r\n            padNumberInMock(self.origDate.getUTCMinutes(), 2) + ':' +\r\n            padNumberInMock(self.origDate.getUTCSeconds(), 2) + '.' +\r\n            padNumberInMock(self.origDate.getUTCMilliseconds(), 3) + 'Z';\r\n    };\r\n  }\r\n\r\n  //hide all methods not implemented in this mock that the Date prototype exposes\r\n  var unimplementedMethods = ['getUTCDay',\r\n      'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\r\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear',\r\n      'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds',\r\n      'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString',\r\n      'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];\r\n\r\n  angular.forEach(unimplementedMethods, function(methodName) {\r\n    self[methodName] = function() {\r\n      throw new Error(\"Method '\" + methodName + \"' is not implemented in the TzDate mock\");\r\n    };\r\n  });\r\n\r\n  return self;\r\n};\r\n\r\n//make \"tzDateInstance instanceof Date\" return true\r\nangular.mock.TzDate.prototype = Date.prototype;\r\n/* jshint +W101 */\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $animate\r\n *\r\n * @description\r\n * Mock implementation of the {@link ng.$animate `$animate`} service. Exposes two additional methods\r\n * for testing animations.\r\n *\r\n * You need to require the `ngAnimateMock` module in your test suite for instance `beforeEach(module('ngAnimateMock'))`\r\n */\r\nangular.mock.animate = angular.module('ngAnimateMock', ['ng'])\r\n\r\n  .config(['$provide', function($provide) {\r\n\r\n    $provide.factory('$$forceReflow', function() {\r\n      function reflowFn() {\r\n        reflowFn.totalReflows++;\r\n      }\r\n      reflowFn.totalReflows = 0;\r\n      return reflowFn;\r\n    });\r\n\r\n    $provide.factory('$$animateAsyncRun', function() {\r\n      var queue = [];\r\n      var queueFn = function() {\r\n        return function(fn) {\r\n          queue.push(fn);\r\n        };\r\n      };\r\n      queueFn.flush = function() {\r\n        if (queue.length === 0) return false;\r\n\r\n        for (var i = 0; i < queue.length; i++) {\r\n          queue[i]();\r\n        }\r\n        queue = [];\r\n\r\n        return true;\r\n      };\r\n      return queueFn;\r\n    });\r\n\r\n    $provide.decorator('$$animateJs', ['$delegate', function($delegate) {\r\n      var runners = [];\r\n\r\n      var animateJsConstructor = function() {\r\n        var animator = $delegate.apply($delegate, arguments);\r\n        // If no javascript animation is found, animator is undefined\r\n        if (animator) {\r\n          runners.push(animator);\r\n        }\r\n        return animator;\r\n      };\r\n\r\n      animateJsConstructor.$closeAndFlush = function() {\r\n        runners.forEach(function(runner) {\r\n          runner.end();\r\n        });\r\n        runners = [];\r\n      };\r\n\r\n      return animateJsConstructor;\r\n    }]);\r\n\r\n    $provide.decorator('$animateCss', ['$delegate', function($delegate) {\r\n      var runners = [];\r\n\r\n      var animateCssConstructor = function(element, options) {\r\n        var animator = $delegate(element, options);\r\n        runners.push(animator);\r\n        return animator;\r\n      };\r\n\r\n      animateCssConstructor.$closeAndFlush = function() {\r\n        runners.forEach(function(runner) {\r\n          runner.end();\r\n        });\r\n        runners = [];\r\n      };\r\n\r\n      return animateCssConstructor;\r\n    }]);\r\n\r\n    $provide.decorator('$animate', ['$delegate', '$timeout', '$browser', '$$rAF', '$animateCss', '$$animateJs',\r\n                                    '$$forceReflow', '$$animateAsyncRun', '$rootScope',\r\n                            function($delegate,   $timeout,   $browser,   $$rAF,   $animateCss,   $$animateJs,\r\n                                     $$forceReflow,   $$animateAsyncRun,  $rootScope) {\r\n      var animate = {\r\n        queue: [],\r\n        cancel: $delegate.cancel,\r\n        on: $delegate.on,\r\n        off: $delegate.off,\r\n        pin: $delegate.pin,\r\n        get reflows() {\r\n          return $$forceReflow.totalReflows;\r\n        },\r\n        enabled: $delegate.enabled,\r\n        /**\r\n         * @ngdoc method\r\n         * @name $animate#closeAndFlush\r\n         * @description\r\n         *\r\n         * This method will close all pending animations (both {@link ngAnimate#javascript-based-animations Javascript}\r\n         * and {@link ngAnimate.$animateCss CSS}) and it will also flush any remaining animation frames and/or callbacks.\r\n         */\r\n        closeAndFlush: function() {\r\n          // we allow the flush command to swallow the errors\r\n          // because depending on whether CSS or JS animations are\r\n          // used, there may not be a RAF flush. The primary flush\r\n          // at the end of this function must throw an exception\r\n          // because it will track if there were pending animations\r\n          this.flush(true);\r\n          $animateCss.$closeAndFlush();\r\n          $$animateJs.$closeAndFlush();\r\n          this.flush();\r\n        },\r\n        /**\r\n         * @ngdoc method\r\n         * @name $animate#flush\r\n         * @description\r\n         *\r\n         * This method is used to flush the pending callbacks and animation frames to either start\r\n         * an animation or conclude an animation. Note that this will not actually close an\r\n         * actively running animation (see {@link ngMock.$animate#closeAndFlush `closeAndFlush()`} for that).\r\n         */\r\n        flush: function(hideErrors) {\r\n          $rootScope.$digest();\r\n\r\n          var doNextRun, somethingFlushed = false;\r\n          do {\r\n            doNextRun = false;\r\n\r\n            if ($$rAF.queue.length) {\r\n              $$rAF.flush();\r\n              doNextRun = somethingFlushed = true;\r\n            }\r\n\r\n            if ($$animateAsyncRun.flush()) {\r\n              doNextRun = somethingFlushed = true;\r\n            }\r\n          } while (doNextRun);\r\n\r\n          if (!somethingFlushed && !hideErrors) {\r\n            throw new Error('No pending animations ready to be closed or flushed');\r\n          }\r\n\r\n          $rootScope.$digest();\r\n        }\r\n      };\r\n\r\n      angular.forEach(\r\n        ['animate','enter','leave','move','addClass','removeClass','setClass'], function(method) {\r\n        animate[method] = function() {\r\n          animate.queue.push({\r\n            event: method,\r\n            element: arguments[0],\r\n            options: arguments[arguments.length - 1],\r\n            args: arguments\r\n          });\r\n          return $delegate[method].apply($delegate, arguments);\r\n        };\r\n      });\r\n\r\n      return animate;\r\n    }]);\r\n\r\n  }]);\r\n\r\n\r\n/**\r\n * @ngdoc function\r\n * @name angular.mock.dump\r\n * @description\r\n *\r\n * *NOTE*: This is not an injectable instance, just a globally available function.\r\n *\r\n * Method for serializing common angular objects (scope, elements, etc..) into strings.\r\n * It is useful for logging objects to the console when debugging.\r\n *\r\n * @param {*} object - any object to turn into string.\r\n * @return {string} a serialized string of the argument\r\n */\r\nangular.mock.dump = function(object) {\r\n  return serialize(object);\r\n\r\n  function serialize(object) {\r\n    var out;\r\n\r\n    if (angular.isElement(object)) {\r\n      object = angular.element(object);\r\n      out = angular.element('<div></div>');\r\n      angular.forEach(object, function(element) {\r\n        out.append(angular.element(element).clone());\r\n      });\r\n      out = out.html();\r\n    } else if (angular.isArray(object)) {\r\n      out = [];\r\n      angular.forEach(object, function(o) {\r\n        out.push(serialize(o));\r\n      });\r\n      out = '[ ' + out.join(', ') + ' ]';\r\n    } else if (angular.isObject(object)) {\r\n      if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {\r\n        out = serializeScope(object);\r\n      } else if (object instanceof Error) {\r\n        out = object.stack || ('' + object.name + ': ' + object.message);\r\n      } else {\r\n        // TODO(i): this prevents methods being logged,\r\n        // we should have a better way to serialize objects\r\n        out = angular.toJson(object, true);\r\n      }\r\n    } else {\r\n      out = String(object);\r\n    }\r\n\r\n    return out;\r\n  }\r\n\r\n  function serializeScope(scope, offset) {\r\n    offset = offset ||  '  ';\r\n    var log = [offset + 'Scope(' + scope.$id + '): {'];\r\n    for (var key in scope) {\r\n      if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\\$|this)/)) {\r\n        log.push('  ' + key + ': ' + angular.toJson(scope[key]));\r\n      }\r\n    }\r\n    var child = scope.$$childHead;\r\n    while (child) {\r\n      log.push(serializeScope(child, offset + '  '));\r\n      child = child.$$nextSibling;\r\n    }\r\n    log.push('}');\r\n    return log.join('\\n' + offset);\r\n  }\r\n};\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $httpBackend\r\n * @description\r\n * Fake HTTP backend implementation suitable for unit testing applications that use the\r\n * {@link ng.$http $http service}.\r\n *\r\n * <div class=\"alert alert-info\">\r\n * **Note**: For fake HTTP backend implementation suitable for end-to-end testing or backend-less\r\n * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.\r\n * </div>\r\n *\r\n * During unit testing, we want our unit tests to run quickly and have no external dependencies so\r\n * we dont want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or\r\n * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is\r\n * to verify whether a certain request has been sent or not, or alternatively just let the\r\n * application make requests, respond with pre-trained responses and assert that the end result is\r\n * what we expect it to be.\r\n *\r\n * This mock implementation can be used to respond with static or dynamic responses via the\r\n * `expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).\r\n *\r\n * When an Angular application needs some data from a server, it calls the $http service, which\r\n * sends the request to a real server using $httpBackend service. With dependency injection, it is\r\n * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify\r\n * the requests and respond with some testing data without sending a request to a real server.\r\n *\r\n * There are two ways to specify what test data should be returned as http responses by the mock\r\n * backend when the code under test makes http requests:\r\n *\r\n * - `$httpBackend.expect` - specifies a request expectation\r\n * - `$httpBackend.when` - specifies a backend definition\r\n *\r\n *\r\n * ## Request Expectations vs Backend Definitions\r\n *\r\n * Request expectations provide a way to make assertions about requests made by the application and\r\n * to define responses for those requests. The test will fail if the expected requests are not made\r\n * or they are made in the wrong order.\r\n *\r\n * Backend definitions allow you to define a fake backend for your application which doesn't assert\r\n * if a particular request was made or not, it just returns a trained response if a request is made.\r\n * The test will pass whether or not the request gets made during testing.\r\n *\r\n *\r\n * <table class=\"table\">\r\n *   <tr><th width=\"220px\"></th><th>Request expectations</th><th>Backend definitions</th></tr>\r\n *   <tr>\r\n *     <th>Syntax</th>\r\n *     <td>.expect(...).respond(...)</td>\r\n *     <td>.when(...).respond(...)</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Typical usage</th>\r\n *     <td>strict unit tests</td>\r\n *     <td>loose (black-box) unit testing</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Fulfills multiple requests</th>\r\n *     <td>NO</td>\r\n *     <td>YES</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Order of requests matters</th>\r\n *     <td>YES</td>\r\n *     <td>NO</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Request required</th>\r\n *     <td>YES</td>\r\n *     <td>NO</td>\r\n *   </tr>\r\n *   <tr>\r\n *     <th>Response required</th>\r\n *     <td>optional (see below)</td>\r\n *     <td>YES</td>\r\n *   </tr>\r\n * </table>\r\n *\r\n * In cases where both backend definitions and request expectations are specified during unit\r\n * testing, the request expectations are evaluated first.\r\n *\r\n * If a request expectation has no response specified, the algorithm will search your backend\r\n * definitions for an appropriate response.\r\n *\r\n * If a request didn't match any expectation or if the expectation doesn't have the response\r\n * defined, the backend definitions are evaluated in sequential order to see if any of them match\r\n * the request. The response from the first matched definition is returned.\r\n *\r\n *\r\n * ## Flushing HTTP requests\r\n *\r\n * The $httpBackend used in production always responds to requests asynchronously. If we preserved\r\n * this behavior in unit testing, we'd have to create async unit tests, which are hard to write,\r\n * to follow and to maintain. But neither can the testing mock respond synchronously; that would\r\n * change the execution of the code under test. For this reason, the mock $httpBackend has a\r\n * `flush()` method, which allows the test to explicitly flush pending requests. This preserves\r\n * the async api of the backend, while allowing the test to execute synchronously.\r\n *\r\n *\r\n * ## Unit testing with mock $httpBackend\r\n * The following code shows how to setup and use the mock backend when unit testing a controller.\r\n * First we create the controller under test:\r\n *\r\n  ```js\r\n  // The module code\r\n  angular\r\n    .module('MyApp', [])\r\n    .controller('MyController', MyController);\r\n\r\n  // The controller code\r\n  function MyController($scope, $http) {\r\n    var authToken;\r\n\r\n    $http.get('/auth.py').then(function(response) {\r\n      authToken = response.headers('A-Token');\r\n      $scope.user = response.data;\r\n    });\r\n\r\n    $scope.saveMessage = function(message) {\r\n      var headers = { 'Authorization': authToken };\r\n      $scope.status = 'Saving...';\r\n\r\n      $http.post('/add-msg.py', message, { headers: headers } ).then(function(response) {\r\n        $scope.status = '';\r\n      }).catch(function() {\r\n        $scope.status = 'Failed...';\r\n      });\r\n    };\r\n  }\r\n  ```\r\n *\r\n * Now we setup the mock backend and create the test specs:\r\n *\r\n  ```js\r\n    // testing controller\r\n    describe('MyController', function() {\r\n       var $httpBackend, $rootScope, createController, authRequestHandler;\r\n\r\n       // Set up the module\r\n       beforeEach(module('MyApp'));\r\n\r\n       beforeEach(inject(function($injector) {\r\n         // Set up the mock http service responses\r\n         $httpBackend = $injector.get('$httpBackend');\r\n         // backend definition common for all tests\r\n         authRequestHandler = $httpBackend.when('GET', '/auth.py')\r\n                                .respond({userId: 'userX'}, {'A-Token': 'xxx'});\r\n\r\n         // Get hold of a scope (i.e. the root scope)\r\n         $rootScope = $injector.get('$rootScope');\r\n         // The $controller service is used to create instances of controllers\r\n         var $controller = $injector.get('$controller');\r\n\r\n         createController = function() {\r\n           return $controller('MyController', {'$scope' : $rootScope });\r\n         };\r\n       }));\r\n\r\n\r\n       afterEach(function() {\r\n         $httpBackend.verifyNoOutstandingExpectation();\r\n         $httpBackend.verifyNoOutstandingRequest();\r\n       });\r\n\r\n\r\n       it('should fetch authentication token', function() {\r\n         $httpBackend.expectGET('/auth.py');\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n       });\r\n\r\n\r\n       it('should fail authentication', function() {\r\n\r\n         // Notice how you can change the response even after it was set\r\n         authRequestHandler.respond(401, '');\r\n\r\n         $httpBackend.expectGET('/auth.py');\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n         expect($rootScope.status).toBe('Failed...');\r\n       });\r\n\r\n\r\n       it('should send msg to server', function() {\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n\r\n         // now you dont care about the authentication, but\r\n         // the controller will still send the request and\r\n         // $httpBackend will respond without you having to\r\n         // specify the expectation and response for this request\r\n\r\n         $httpBackend.expectPOST('/add-msg.py', 'message content').respond(201, '');\r\n         $rootScope.saveMessage('message content');\r\n         expect($rootScope.status).toBe('Saving...');\r\n         $httpBackend.flush();\r\n         expect($rootScope.status).toBe('');\r\n       });\r\n\r\n\r\n       it('should send auth header', function() {\r\n         var controller = createController();\r\n         $httpBackend.flush();\r\n\r\n         $httpBackend.expectPOST('/add-msg.py', undefined, function(headers) {\r\n           // check if the header was sent, if it wasn't the expectation won't\r\n           // match the request and the test will fail\r\n           return headers['Authorization'] == 'xxx';\r\n         }).respond(201, '');\r\n\r\n         $rootScope.saveMessage('whatever');\r\n         $httpBackend.flush();\r\n       });\r\n    });\r\n  ```\r\n *\r\n * ## Dynamic responses\r\n *\r\n * You define a response to a request by chaining a call to `respond()` onto a definition or expectation.\r\n * If you provide a **callback** as the first parameter to `respond(callback)` then you can dynamically generate\r\n * a response based on the properties of the request.\r\n *\r\n * The `callback` function should be of the form `function(method, url, data, headers, params)`.\r\n *\r\n * ### Query parameters\r\n *\r\n * By default, query parameters on request URLs are parsed into the `params` object. So a request URL\r\n * of `/list?q=searchstr&orderby=-name` would set `params` to be `{q: 'searchstr', orderby: '-name'}`.\r\n *\r\n * ### Regex parameter matching\r\n *\r\n * If an expectation or definition uses a **regex** to match the URL, you can provide an array of **keys** via a\r\n * `params` argument. The index of each **key** in the array will match the index of a **group** in the\r\n * **regex**.\r\n *\r\n * The `params` object in the **callback** will now have properties with these keys, which hold the value of the\r\n * corresponding **group** in the **regex**.\r\n *\r\n * This also applies to the `when` and `expect` shortcut methods.\r\n *\r\n *\r\n * ```js\r\n *   $httpBackend.expect('GET', /\\/user\\/(.+)/, undefined, undefined, ['id'])\r\n *     .respond(function(method, url, data, headers, params) {\r\n *       // for requested url of '/user/1234' params is {id: '1234'}\r\n *     });\r\n *\r\n *   $httpBackend.whenPATCH(/\\/user\\/(.+)\\/article\\/(.+)/, undefined, undefined, ['user', 'article'])\r\n *     .respond(function(method, url, data, headers, params) {\r\n *       // for url of '/user/1234/article/567' params is {user: '1234', article: '567'}\r\n *     });\r\n * ```\r\n *\r\n * ## Matching route requests\r\n *\r\n * For extra convenience, `whenRoute` and `expectRoute` shortcuts are available. These methods offer colon\r\n * delimited matching of the url path, ignoring the query string. This allows declarations\r\n * similar to how application routes are configured with `$routeProvider`. Because these methods convert\r\n * the definition url to regex, declaration order is important. Combined with query parameter parsing,\r\n * the following is possible:\r\n *\r\n  ```js\r\n    $httpBackend.whenRoute('GET', '/users/:id')\r\n      .respond(function(method, url, data, headers, params) {\r\n        return [200, MockUserList[Number(params.id)]];\r\n      });\r\n\r\n    $httpBackend.whenRoute('GET', '/users')\r\n      .respond(function(method, url, data, headers, params) {\r\n        var userList = angular.copy(MockUserList),\r\n          defaultSort = 'lastName',\r\n          count, pages, isPrevious, isNext;\r\n\r\n        // paged api response '/v1/users?page=2'\r\n        params.page = Number(params.page) || 1;\r\n\r\n        // query for last names '/v1/users?q=Archer'\r\n        if (params.q) {\r\n          userList = $filter('filter')({lastName: params.q});\r\n        }\r\n\r\n        pages = Math.ceil(userList.length / pagingLength);\r\n        isPrevious = params.page > 1;\r\n        isNext = params.page < pages;\r\n\r\n        return [200, {\r\n          count:    userList.length,\r\n          previous: isPrevious,\r\n          next:     isNext,\r\n          // sort field -> '/v1/users?sortBy=firstName'\r\n          results:  $filter('orderBy')(userList, params.sortBy || defaultSort)\r\n                      .splice((params.page - 1) * pagingLength, pagingLength)\r\n        }];\r\n      });\r\n  ```\r\n */\r\nangular.mock.$HttpBackendProvider = function() {\r\n  this.$get = ['$rootScope', '$timeout', createHttpBackendMock];\r\n};\r\n\r\n/**\r\n * General factory function for $httpBackend mock.\r\n * Returns instance for unit testing (when no arguments specified):\r\n *   - passing through is disabled\r\n *   - auto flushing is disabled\r\n *\r\n * Returns instance for e2e testing (when `$delegate` and `$browser` specified):\r\n *   - passing through (delegating request to real backend) is enabled\r\n *   - auto flushing is enabled\r\n *\r\n * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)\r\n * @param {Object=} $browser Auto-flushing enabled if specified\r\n * @return {Object} Instance of $httpBackend mock\r\n */\r\nfunction createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {\r\n  var definitions = [],\r\n      expectations = [],\r\n      responses = [],\r\n      responsesPush = angular.bind(responses, responses.push),\r\n      copy = angular.copy;\r\n\r\n  function createResponse(status, data, headers, statusText) {\r\n    if (angular.isFunction(status)) return status;\r\n\r\n    return function() {\r\n      return angular.isNumber(status)\r\n          ? [status, data, headers, statusText]\r\n          : [200, status, data, headers];\r\n    };\r\n  }\r\n\r\n  // TODO(vojta): change params to: method, url, data, headers, callback\r\n  function $httpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {\r\n\r\n    var xhr = new MockXhr(),\r\n        expectation = expectations[0],\r\n        wasExpected = false;\r\n\r\n    xhr.$$events = eventHandlers;\r\n    xhr.upload.$$events = uploadEventHandlers;\r\n\r\n    function prettyPrint(data) {\r\n      return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)\r\n          ? data\r\n          : angular.toJson(data);\r\n    }\r\n\r\n    function wrapResponse(wrapped) {\r\n      if (!$browser && timeout) {\r\n        timeout.then ? timeout.then(handleTimeout) : $timeout(handleTimeout, timeout);\r\n      }\r\n\r\n      return handleResponse;\r\n\r\n      function handleResponse() {\r\n        var response = wrapped.response(method, url, data, headers, wrapped.params(url));\r\n        xhr.$$respHeaders = response[2];\r\n        callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),\r\n                 copy(response[3] || ''));\r\n      }\r\n\r\n      function handleTimeout() {\r\n        for (var i = 0, ii = responses.length; i < ii; i++) {\r\n          if (responses[i] === handleResponse) {\r\n            responses.splice(i, 1);\r\n            callback(-1, undefined, '');\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (expectation && expectation.match(method, url)) {\r\n      if (!expectation.matchData(data)) {\r\n        throw new Error('Expected ' + expectation + ' with different data\\n' +\r\n            'EXPECTED: ' + prettyPrint(expectation.data) + '\\nGOT:      ' + data);\r\n      }\r\n\r\n      if (!expectation.matchHeaders(headers)) {\r\n        throw new Error('Expected ' + expectation + ' with different headers\\n' +\r\n                        'EXPECTED: ' + prettyPrint(expectation.headers) + '\\nGOT:      ' +\r\n                        prettyPrint(headers));\r\n      }\r\n\r\n      expectations.shift();\r\n\r\n      if (expectation.response) {\r\n        responses.push(wrapResponse(expectation));\r\n        return;\r\n      }\r\n      wasExpected = true;\r\n    }\r\n\r\n    var i = -1, definition;\r\n    while ((definition = definitions[++i])) {\r\n      if (definition.match(method, url, data, headers || {})) {\r\n        if (definition.response) {\r\n          // if $browser specified, we do auto flush all requests\r\n          ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));\r\n        } else if (definition.passThrough) {\r\n          $delegate(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers);\r\n        } else throw new Error('No response defined !');\r\n        return;\r\n      }\r\n    }\r\n    throw wasExpected ?\r\n        new Error('No response defined !') :\r\n        new Error('Unexpected request: ' + method + ' ' + url + '\\n' +\r\n                  (expectation ? 'Expected ' + expectation : 'No more request expected'));\r\n  }\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#when\r\n   * @description\r\n   * Creates a new backend definition.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n   *   data string and returns true if the data is as expected.\r\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\r\n   *   object and returns true if the headers match the current definition.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   *\r\n   *  - respond \r\n   *      ```js\r\n   *      {function([status,] data[, headers, statusText])\r\n   *      | function(function(method, url, data, headers, params)}\r\n   *      ```\r\n   *     The respond method takes a set of static data to be returned or a function that can\r\n   *    return an array containing response status (number), response data (Array|Object|string),\r\n   *    response headers (Object), and the text for the status (string). The respond method returns\r\n   *    the `requestHandler` object for possible overrides.\r\n   */\r\n  $httpBackend.when = function(method, url, data, headers, keys) {\r\n    var definition = new MockHttpExpectation(method, url, data, headers, keys),\r\n        chain = {\r\n          respond: function(status, data, headers, statusText) {\r\n            definition.passThrough = undefined;\r\n            definition.response = createResponse(status, data, headers, statusText);\r\n            return chain;\r\n          }\r\n        };\r\n\r\n    if ($browser) {\r\n      chain.passThrough = function() {\r\n        definition.response = undefined;\r\n        definition.passThrough = true;\r\n        return chain;\r\n      };\r\n    }\r\n\r\n    definitions.push(definition);\r\n    return chain;\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenGET\r\n   * @description\r\n   * Creates a new backend definition for GET requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenHEAD\r\n   * @description\r\n   * Creates a new backend definition for HEAD requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenDELETE\r\n   * @description\r\n   * Creates a new backend definition for DELETE requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenPOST\r\n   * @description\r\n   * Creates a new backend definition for POST requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n   *   data string and returns true if the data is as expected.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenPUT\r\n   * @description\r\n   * Creates a new backend definition for PUT requests.  For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\r\n   *   data string and returns true if the data is as expected.\r\n   * @param {(Object|function(Object))=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenJSONP\r\n   * @description\r\n   * Creates a new backend definition for JSONP requests. For more info see `when()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled.\r\n   */\r\n  createShortMethods('when');\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#whenRoute\r\n   * @description\r\n   * Creates a new backend definition that compares only with the requested route.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string} url HTTP url string that supports colon param matching.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled. See #when for more info.\r\n   */\r\n  $httpBackend.whenRoute = function(method, url) {\r\n    var pathObj = parseRoute(url);\r\n    return $httpBackend.when(method, pathObj.regexp, undefined, undefined, pathObj.keys);\r\n  };\r\n\r\n  function parseRoute(url) {\r\n    var ret = {\r\n      regexp: url\r\n    },\r\n    keys = ret.keys = [];\r\n\r\n    if (!url || !angular.isString(url)) return ret;\r\n\r\n    url = url\r\n      .replace(/([().])/g, '\\\\$1')\r\n      .replace(/(\\/)?:(\\w+)([\\?\\*])?/g, function(_, slash, key, option) {\r\n        var optional = option === '?' ? option : null;\r\n        var star = option === '*' ? option : null;\r\n        keys.push({ name: key, optional: !!optional });\r\n        slash = slash || '';\r\n        return ''\r\n          + (optional ? '' : slash)\r\n          + '(?:'\r\n          + (optional ? slash : '')\r\n          + (star && '(.+?)' || '([^/]+)')\r\n          + (optional || '')\r\n          + ')'\r\n          + (optional || '');\r\n      })\r\n      .replace(/([\\/$\\*])/g, '\\\\$1');\r\n\r\n    ret.regexp = new RegExp('^' + url, 'i');\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expect\r\n   * @description\r\n   * Creates a new request expectation.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\r\n   *   object and returns true if the headers match the current expectation.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *  request is handled. You can save this object for later use and invoke `respond` again in\r\n   *  order to change how a matched request is handled.\r\n   *\r\n   *  - respond \r\n   *    ```\r\n   *    { function([status,] data[, headers, statusText])\r\n   *    | function(function(method, url, data, headers, params)}\r\n   *    ```\r\n   *     The respond method takes a set of static data to be returned or a function that can\r\n   *    return an array containing response status (number), response data (Array|Object|string),\r\n   *    response headers (Object), and the text for the status (string). The respond method returns\r\n   *    the `requestHandler` object for possible overrides.\r\n   */\r\n  $httpBackend.expect = function(method, url, data, headers, keys) {\r\n    var expectation = new MockHttpExpectation(method, url, data, headers, keys),\r\n        chain = {\r\n          respond: function(status, data, headers, statusText) {\r\n            expectation.response = createResponse(status, data, headers, statusText);\r\n            return chain;\r\n          }\r\n        };\r\n\r\n    expectations.push(expectation);\r\n    return chain;\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectGET\r\n   * @description\r\n   * Creates a new request expectation for GET requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled. See #expect for more info.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectHEAD\r\n   * @description\r\n   * Creates a new request expectation for HEAD requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectDELETE\r\n   * @description\r\n   * Creates a new request expectation for DELETE requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectPOST\r\n   * @description\r\n   * Creates a new request expectation for POST requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectPUT\r\n   * @description\r\n   * Creates a new request expectation for PUT requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectPATCH\r\n   * @description\r\n   * Creates a new request expectation for PATCH requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\r\n   *  receives data string and returns true if the data is as expected, or Object if request body\r\n   *  is in JSON format.\r\n   * @param {Object=} headers HTTP headers.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectJSONP\r\n   * @description\r\n   * Creates a new request expectation for JSONP requests. For more info see `expect()`.\r\n   *\r\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives an url\r\n   *   and returns true if the url matches the current definition.\r\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   *   request is handled. You can save this object for later use and invoke `respond` again in\r\n   *   order to change how a matched request is handled.\r\n   */\r\n  createShortMethods('expect');\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#expectRoute\r\n   * @description\r\n   * Creates a new request expectation that compares only with the requested route.\r\n   *\r\n   * @param {string} method HTTP method.\r\n   * @param {string} url HTTP url string that supports colon param matching.\r\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\r\n   * request is handled. You can save this object for later use and invoke `respond` again in\r\n   * order to change how a matched request is handled. See #expect for more info.\r\n   */\r\n  $httpBackend.expectRoute = function(method, url) {\r\n    var pathObj = parseRoute(url);\r\n    return $httpBackend.expect(method, pathObj.regexp, undefined, undefined, pathObj.keys);\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#flush\r\n   * @description\r\n   * Flushes all pending requests using the trained responses.\r\n   *\r\n   * @param {number=} count Number of responses to flush (in the order they arrived). If undefined,\r\n   *   all pending requests will be flushed. If there are no pending requests when the flush method\r\n   *   is called an exception is thrown (as this typically a sign of programming error).\r\n   */\r\n  $httpBackend.flush = function(count, digest) {\r\n    if (digest !== false) $rootScope.$digest();\r\n    if (!responses.length) throw new Error('No pending request to flush !');\r\n\r\n    if (angular.isDefined(count) && count !== null) {\r\n      while (count--) {\r\n        if (!responses.length) throw new Error('No more pending request to flush !');\r\n        responses.shift()();\r\n      }\r\n    } else {\r\n      while (responses.length) {\r\n        responses.shift()();\r\n      }\r\n    }\r\n    $httpBackend.verifyNoOutstandingExpectation(digest);\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#verifyNoOutstandingExpectation\r\n   * @description\r\n   * Verifies that all of the requests defined via the `expect` api were made. If any of the\r\n   * requests were not made, verifyNoOutstandingExpectation throws an exception.\r\n   *\r\n   * Typically, you would call this method following each test case that asserts requests using an\r\n   * \"afterEach\" clause.\r\n   *\r\n   * ```js\r\n   *   afterEach($httpBackend.verifyNoOutstandingExpectation);\r\n   * ```\r\n   */\r\n  $httpBackend.verifyNoOutstandingExpectation = function(digest) {\r\n    if (digest !== false) $rootScope.$digest();\r\n    if (expectations.length) {\r\n      throw new Error('Unsatisfied requests: ' + expectations.join(', '));\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#verifyNoOutstandingRequest\r\n   * @description\r\n   * Verifies that there are no outstanding requests that need to be flushed.\r\n   *\r\n   * Typically, you would call this method following each test case that asserts requests using an\r\n   * \"afterEach\" clause.\r\n   *\r\n   * ```js\r\n   *   afterEach($httpBackend.verifyNoOutstandingRequest);\r\n   * ```\r\n   */\r\n  $httpBackend.verifyNoOutstandingRequest = function() {\r\n    if (responses.length) {\r\n      throw new Error('Unflushed requests: ' + responses.length);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $httpBackend#resetExpectations\r\n   * @description\r\n   * Resets all request expectations, but preserves all backend definitions. Typically, you would\r\n   * call resetExpectations during a multiple-phase test when you want to reuse the same instance of\r\n   * $httpBackend mock.\r\n   */\r\n  $httpBackend.resetExpectations = function() {\r\n    expectations.length = 0;\r\n    responses.length = 0;\r\n  };\r\n\r\n  return $httpBackend;\r\n\r\n\r\n  function createShortMethods(prefix) {\r\n    angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {\r\n     $httpBackend[prefix + method] = function(url, headers, keys) {\r\n       return $httpBackend[prefix](method, url, undefined, headers, keys);\r\n     };\r\n    });\r\n\r\n    angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {\r\n      $httpBackend[prefix + method] = function(url, data, headers, keys) {\r\n        return $httpBackend[prefix](method, url, data, headers, keys);\r\n      };\r\n    });\r\n  }\r\n}\r\n\r\nfunction MockHttpExpectation(method, url, data, headers, keys) {\r\n\r\n  function getUrlParams(u) {\r\n    var params = u.slice(u.indexOf('?') + 1).split('&');\r\n    return params.sort();\r\n  }\r\n\r\n  function compareUrl(u) {\r\n    return (url.slice(0, url.indexOf('?')) == u.slice(0, u.indexOf('?')) && getUrlParams(url).join() == getUrlParams(u).join());\r\n  }\r\n\r\n  this.data = data;\r\n  this.headers = headers;\r\n\r\n  this.match = function(m, u, d, h) {\r\n    if (method != m) return false;\r\n    if (!this.matchUrl(u)) return false;\r\n    if (angular.isDefined(d) && !this.matchData(d)) return false;\r\n    if (angular.isDefined(h) && !this.matchHeaders(h)) return false;\r\n    return true;\r\n  };\r\n\r\n  this.matchUrl = function(u) {\r\n    if (!url) return true;\r\n    if (angular.isFunction(url.test)) return url.test(u);\r\n    if (angular.isFunction(url)) return url(u);\r\n    return (url == u || compareUrl(u));\r\n  };\r\n\r\n  this.matchHeaders = function(h) {\r\n    if (angular.isUndefined(headers)) return true;\r\n    if (angular.isFunction(headers)) return headers(h);\r\n    return angular.equals(headers, h);\r\n  };\r\n\r\n  this.matchData = function(d) {\r\n    if (angular.isUndefined(data)) return true;\r\n    if (data && angular.isFunction(data.test)) return data.test(d);\r\n    if (data && angular.isFunction(data)) return data(d);\r\n    if (data && !angular.isString(data)) {\r\n      return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));\r\n    }\r\n    return data == d;\r\n  };\r\n\r\n  this.toString = function() {\r\n    return method + ' ' + url;\r\n  };\r\n\r\n  this.params = function(u) {\r\n    return angular.extend(parseQuery(), pathParams());\r\n\r\n    function pathParams() {\r\n      var keyObj = {};\r\n      if (!url || !angular.isFunction(url.test) || !keys || keys.length === 0) return keyObj;\r\n\r\n      var m = url.exec(u);\r\n      if (!m) return keyObj;\r\n      for (var i = 1, len = m.length; i < len; ++i) {\r\n        var key = keys[i - 1];\r\n        var val = m[i];\r\n        if (key && val) {\r\n          keyObj[key.name || key] = val;\r\n        }\r\n      }\r\n\r\n      return keyObj;\r\n    }\r\n\r\n    function parseQuery() {\r\n      var obj = {}, key_value, key,\r\n          queryStr = u.indexOf('?') > -1\r\n          ? u.substring(u.indexOf('?') + 1)\r\n          : \"\";\r\n\r\n      angular.forEach(queryStr.split('&'), function(keyValue) {\r\n        if (keyValue) {\r\n          key_value = keyValue.replace(/\\+/g,'%20').split('=');\r\n          key = tryDecodeURIComponent(key_value[0]);\r\n          if (angular.isDefined(key)) {\r\n            var val = angular.isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;\r\n            if (!hasOwnProperty.call(obj, key)) {\r\n              obj[key] = val;\r\n            } else if (angular.isArray(obj[key])) {\r\n              obj[key].push(val);\r\n            } else {\r\n              obj[key] = [obj[key],val];\r\n            }\r\n          }\r\n        }\r\n      });\r\n      return obj;\r\n    }\r\n    function tryDecodeURIComponent(value) {\r\n      try {\r\n        return decodeURIComponent(value);\r\n      } catch (e) {\r\n        // Ignore any invalid uri component\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nfunction createMockXhr() {\r\n  return new MockXhr();\r\n}\r\n\r\nfunction MockXhr() {\r\n\r\n  // hack for testing $http, $httpBackend\r\n  MockXhr.$$lastInstance = this;\r\n\r\n  this.open = function(method, url, async) {\r\n    this.$$method = method;\r\n    this.$$url = url;\r\n    this.$$async = async;\r\n    this.$$reqHeaders = {};\r\n    this.$$respHeaders = {};\r\n  };\r\n\r\n  this.send = function(data) {\r\n    this.$$data = data;\r\n  };\r\n\r\n  this.setRequestHeader = function(key, value) {\r\n    this.$$reqHeaders[key] = value;\r\n  };\r\n\r\n  this.getResponseHeader = function(name) {\r\n    // the lookup must be case insensitive,\r\n    // that's why we try two quick lookups first and full scan last\r\n    var header = this.$$respHeaders[name];\r\n    if (header) return header;\r\n\r\n    name = angular.lowercase(name);\r\n    header = this.$$respHeaders[name];\r\n    if (header) return header;\r\n\r\n    header = undefined;\r\n    angular.forEach(this.$$respHeaders, function(headerVal, headerName) {\r\n      if (!header && angular.lowercase(headerName) == name) header = headerVal;\r\n    });\r\n    return header;\r\n  };\r\n\r\n  this.getAllResponseHeaders = function() {\r\n    var lines = [];\r\n\r\n    angular.forEach(this.$$respHeaders, function(value, key) {\r\n      lines.push(key + ': ' + value);\r\n    });\r\n    return lines.join('\\n');\r\n  };\r\n\r\n  this.abort = angular.noop;\r\n\r\n  // This section simulates the events on a real XHR object (and the upload object)\r\n  // When we are testing $httpBackend (inside the angular project) we make partial use of this\r\n  // but store the events directly ourselves on `$$events`, instead of going through the `addEventListener`\r\n  this.$$events = {};\r\n  this.addEventListener = function(name, listener) {\r\n    if (angular.isUndefined(this.$$events[name])) this.$$events[name] = [];\r\n    this.$$events[name].push(listener);\r\n  };\r\n\r\n  this.upload = {\r\n    $$events: {},\r\n    addEventListener: this.addEventListener\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $timeout\r\n * @description\r\n *\r\n * This service is just a simple decorator for {@link ng.$timeout $timeout} service\r\n * that adds a \"flush\" and \"verifyNoPendingTasks\" methods.\r\n */\r\n\r\nangular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $timeout#flush\r\n   * @description\r\n   *\r\n   * Flushes the queue of pending tasks.\r\n   *\r\n   * @param {number=} delay maximum timeout amount to flush up until\r\n   */\r\n  $delegate.flush = function(delay) {\r\n    $browser.defer.flush(delay);\r\n  };\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $timeout#verifyNoPendingTasks\r\n   * @description\r\n   *\r\n   * Verifies that there are no pending tasks that need to be flushed.\r\n   */\r\n  $delegate.verifyNoPendingTasks = function() {\r\n    if ($browser.deferredFns.length) {\r\n      throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' +\r\n          formatPendingTasksAsString($browser.deferredFns));\r\n    }\r\n  };\r\n\r\n  function formatPendingTasksAsString(tasks) {\r\n    var result = [];\r\n    angular.forEach(tasks, function(task) {\r\n      result.push('{id: ' + task.id + ', ' + 'time: ' + task.time + '}');\r\n    });\r\n\r\n    return result.join(', ');\r\n  }\r\n\r\n  return $delegate;\r\n}];\r\n\r\nangular.mock.$RAFDecorator = ['$delegate', function($delegate) {\r\n  var rafFn = function(fn) {\r\n    var index = rafFn.queue.length;\r\n    rafFn.queue.push(fn);\r\n    return function() {\r\n      rafFn.queue.splice(index, 1);\r\n    };\r\n  };\r\n\r\n  rafFn.queue = [];\r\n  rafFn.supported = $delegate.supported;\r\n\r\n  rafFn.flush = function() {\r\n    if (rafFn.queue.length === 0) {\r\n      throw new Error('No rAF callbacks present');\r\n    }\r\n\r\n    var length = rafFn.queue.length;\r\n    for (var i = 0; i < length; i++) {\r\n      rafFn.queue[i]();\r\n    }\r\n\r\n    rafFn.queue = rafFn.queue.slice(i);\r\n  };\r\n\r\n  return rafFn;\r\n}];\r\n\r\n/**\r\n *\r\n */\r\nvar originalRootElement;\r\nangular.mock.$RootElementProvider = function() {\r\n  this.$get = ['$injector', function($injector) {\r\n    originalRootElement = angular.element('<div ng-app></div>').data('$injector', $injector);\r\n    return originalRootElement;\r\n  }];\r\n};\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $controller\r\n * @description\r\n * A decorator for {@link ng.$controller} with additional `bindings` parameter, useful when testing\r\n * controllers of directives that use {@link $compile#-bindtocontroller- `bindToController`}.\r\n *\r\n *\r\n * ## Example\r\n *\r\n * ```js\r\n *\r\n * // Directive definition ...\r\n *\r\n * myMod.directive('myDirective', {\r\n *   controller: 'MyDirectiveController',\r\n *   bindToController: {\r\n *     name: '@'\r\n *   }\r\n * });\r\n *\r\n *\r\n * // Controller definition ...\r\n *\r\n * myMod.controller('MyDirectiveController', ['$log', function($log) {\r\n *   $log.info(this.name);\r\n * }]);\r\n *\r\n *\r\n * // In a test ...\r\n *\r\n * describe('myDirectiveController', function() {\r\n *   it('should write the bound name to the log', inject(function($controller, $log) {\r\n *     var ctrl = $controller('MyDirectiveController', { /* no locals &#42;/ }, { name: 'Clark Kent' });\r\n *     expect(ctrl.name).toEqual('Clark Kent');\r\n *     expect($log.info.logs).toEqual(['Clark Kent']);\r\n *   }));\r\n * });\r\n *\r\n * ```\r\n *\r\n * @param {Function|string} constructor If called with a function then it's considered to be the\r\n *    controller constructor function. Otherwise it's considered to be a string which is used\r\n *    to retrieve the controller constructor using the following steps:\r\n *\r\n *    * check if a controller with given name is registered via `$controllerProvider`\r\n *    * check if evaluating the string on the current scope returns a constructor\r\n *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global\r\n *      `window` object (not recommended)\r\n *\r\n *    The string can use the `controller as property` syntax, where the controller instance is published\r\n *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this\r\n *    to work correctly.\r\n *\r\n * @param {Object} locals Injection locals for Controller.\r\n * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used\r\n *                           to simulate the `bindToController` feature and simplify certain kinds of tests.\r\n * @return {Object} Instance of given controller.\r\n */\r\nangular.mock.$ControllerDecorator = ['$delegate', function($delegate) {\r\n  return function(expression, locals, later, ident) {\r\n    if (later && typeof later === 'object') {\r\n      var instantiate = $delegate(expression, locals, true, ident);\r\n      angular.extend(instantiate.instance, later);\r\n\r\n      var instance = instantiate();\r\n      if (instance !== instantiate.instance) {\r\n        angular.extend(instance, later);\r\n      }\r\n\r\n      return instance;\r\n    }\r\n    return $delegate(expression, locals, later, ident);\r\n  };\r\n}];\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $componentController\r\n * @description\r\n * A service that can be used to create instances of component controllers.\r\n * <div class=\"alert alert-info\">\r\n * Be aware that the controller will be instantiated and attached to the scope as specified in\r\n * the component definition object. If you do not provide a `$scope` object in the `locals` param\r\n * then the helper will create a new isolated scope as a child of `$rootScope`.\r\n * </div>\r\n * @param {string} componentName the name of the component whose controller we want to instantiate\r\n * @param {Object} locals Injection locals for Controller.\r\n * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used\r\n *                           to simulate the `bindToController` feature and simplify certain kinds of tests.\r\n * @param {string=} ident Override the property name to use when attaching the controller to the scope.\r\n * @return {Object} Instance of requested controller.\r\n */\r\nangular.mock.$ComponentControllerProvider = ['$compileProvider', function($compileProvider) {\r\n  this.$get = ['$controller','$injector', '$rootScope', function($controller, $injector, $rootScope) {\r\n    return function $componentController(componentName, locals, bindings, ident) {\r\n      // get all directives associated to the component name\r\n      var directives = $injector.get(componentName + 'Directive');\r\n      // look for those directives that are components\r\n      var candidateDirectives = directives.filter(function(directiveInfo) {\r\n        // components have controller, controllerAs and restrict:'E'\r\n        return directiveInfo.controller && directiveInfo.controllerAs && directiveInfo.restrict === 'E';\r\n      });\r\n      // check if valid directives found\r\n      if (candidateDirectives.length === 0) {\r\n        throw new Error('No component found');\r\n      }\r\n      if (candidateDirectives.length > 1) {\r\n        throw new Error('Too many components found');\r\n      }\r\n      // get the info of the component\r\n      var directiveInfo = candidateDirectives[0];\r\n      // create a scope if needed\r\n      locals = locals || {};\r\n      locals.$scope = locals.$scope || $rootScope.$new(true);\r\n      return $controller(directiveInfo.controller, locals, bindings, ident || directiveInfo.controllerAs);\r\n    };\r\n  }];\r\n}];\r\n\r\n\r\n/**\r\n * @ngdoc module\r\n * @name ngMock\r\n * @packageName angular-mocks\r\n * @description\r\n *\r\n * # ngMock\r\n *\r\n * The `ngMock` module provides support to inject and mock Angular services into unit tests.\r\n * In addition, ngMock also extends various core ng services such that they can be\r\n * inspected and controlled in a synchronous manner within test code.\r\n *\r\n *\r\n * <div doc-module-components=\"ngMock\"></div>\r\n *\r\n * @installation\r\n *\r\n *  First, download the file:\r\n *  * [Google CDN](https://developers.google.com/speed/libraries/devguide#angularjs) e.g.\r\n *    `\"//ajax.googleapis.com/ajax/libs/angularjs/X.Y.Z/angular-mocks.js\"`\r\n *  * [NPM](https://www.npmjs.com/) e.g. `npm install angular-mocks@X.Y.Z`\r\n *  * [Bower](http://bower.io) e.g. `bower install angular-mocks#X.Y.Z`\r\n *  * [code.angularjs.org](https://code.angularjs.org/) (discouraged for production use)  e.g.\r\n *    `\"//code.angularjs.org/X.Y.Z/angular-mocks.js\"`\r\n *\r\n * where X.Y.Z is the AngularJS version you are running.\r\n *\r\n * Then, configure your test runner to load `angular-mocks.js` after `angular.js`.\r\n * This example uses <a href=\"http://karma-runner.github.io/\">Karma</a>:\r\n *\r\n * ```\r\n * config.set({\r\n *   files: [\r\n *     'build/angular.js', // and other module files you need\r\n *     'build/angular-mocks.js',\r\n *     '<path/to/application/files>',\r\n *     '<path/to/spec/files>'\r\n *   ]\r\n * });\r\n * ```\r\n *\r\n * Including the `angular-mocks.js` file automatically adds the `ngMock` module, so your tests\r\n *  are ready to go!\r\n */\r\nangular.module('ngMock', ['ng']).provider({\r\n  $browser: angular.mock.$BrowserProvider,\r\n  $exceptionHandler: angular.mock.$ExceptionHandlerProvider,\r\n  $log: angular.mock.$LogProvider,\r\n  $interval: angular.mock.$IntervalProvider,\r\n  $httpBackend: angular.mock.$HttpBackendProvider,\r\n  $rootElement: angular.mock.$RootElementProvider,\r\n  $componentController: angular.mock.$ComponentControllerProvider\r\n}).config(['$provide', function($provide) {\r\n  $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);\r\n  $provide.decorator('$$rAF', angular.mock.$RAFDecorator);\r\n  $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);\r\n  $provide.decorator('$controller', angular.mock.$ControllerDecorator);\r\n}]);\r\n\r\n/**\r\n * @ngdoc module\r\n * @name ngMockE2E\r\n * @module ngMockE2E\r\n * @packageName angular-mocks\r\n * @description\r\n *\r\n * The `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.\r\n * Currently there is only one mock present in this module -\r\n * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.\r\n */\r\nangular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {\r\n  $provide.value('$httpBackend', angular.injector(['ng']).get('$httpBackend'));\r\n  $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);\r\n}]);\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $httpBackend\r\n * @module ngMockE2E\r\n * @description\r\n * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of\r\n * applications that use the {@link ng.$http $http service}.\r\n *\r\n * <div class=\"alert alert-info\">\r\n * **Note**: For fake http backend implementation suitable for unit testing please see\r\n * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.\r\n * </div>\r\n *\r\n * This implementation can be used to respond with static or dynamic responses via the `when` api\r\n * and its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the\r\n * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch\r\n * templates from a webserver).\r\n *\r\n * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application\r\n * is being developed with the real backend api replaced with a mock, it is often desirable for\r\n * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch\r\n * templates or static files from the webserver). To configure the backend with this behavior\r\n * use the `passThrough` request handler of `when` instead of `respond`.\r\n *\r\n * Additionally, we don't want to manually have to flush mocked out requests like we do during unit\r\n * testing. For this reason the e2e $httpBackend flushes mocked out requests\r\n * automatically, closely simulating the behavior of the XMLHttpRequest object.\r\n *\r\n * To setup the application to run with this http backend, you have to create a module that depends\r\n * on the `ngMockE2E` and your application modules and defines the fake backend:\r\n *\r\n * ```js\r\n *   var myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);\r\n *   myAppDev.run(function($httpBackend) {\r\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\r\n *\r\n *     // returns the current list of phones\r\n *     $httpBackend.whenGET('/phones').respond(phones);\r\n *\r\n *     // adds a new phone to the phones array\r\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\r\n *       var phone = angular.fromJson(data);\r\n *       phones.push(phone);\r\n *       return [200, phone, {}];\r\n *     });\r\n *     $httpBackend.whenGET(/^\\/templates\\//).passThrough(); // Requests for templare are handled by the real server\r\n *     //...\r\n *   });\r\n * ```\r\n *\r\n * Afterwards, bootstrap your app with this new module.\r\n *\r\n * ## Example\r\n * <example name=\"httpbackend-e2e-testing\" module=\"myAppE2E\" deps=\"angular-mocks.js\">\r\n * <file name=\"app.js\">\r\n *   var myApp = angular.module('myApp', []);\r\n *\r\n *   myApp.controller('main', function($http) {\r\n *     var ctrl = this;\r\n *\r\n *     ctrl.phones = [];\r\n *     ctrl.newPhone = {\r\n *       name: ''\r\n *     };\r\n *\r\n *     ctrl.getPhones = function() {\r\n *       $http.get('/phones').then(function(response) {\r\n *         ctrl.phones = response.data;\r\n *       });\r\n *     };\r\n *\r\n *     ctrl.addPhone = function(phone) {\r\n *       $http.post('/phones', phone).then(function() {\r\n *         ctrl.newPhone = {name: ''};\r\n *         return ctrl.getPhones();\r\n *       });\r\n *     };\r\n *\r\n *     ctrl.getPhones();\r\n *   });\r\n * </file>\r\n * <file name=\"e2e.js\">\r\n *   var myAppDev = angular.module('myAppE2E', ['myApp', 'ngMockE2E']);\r\n *\r\n *   myAppDev.run(function($httpBackend) {\r\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\r\n *\r\n *     // returns the current list of phones\r\n *     $httpBackend.whenGET('/phones').respond(phones);\r\n *\r\n *     // adds a new phone to the phones array\r\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\r\n *       var phone = angular.fromJson(data);\r\n *       phones.push(phone);\r\n *       return [200, phone, {}];\r\n *     });\r\n *   });\r\n * </file>\r\n * <file name=\"index.html\">\r\n *   <div ng-controller=\"main as $ctrl\">\r\n *   <form name=\"newPhoneForm\" ng-submit=\"$ctrl.addPhone($ctrl.newPhone)\">\r\n *     <input type=\"text\" ng-model=\"$ctrl.newPhone.name\">\r\n *     <input type=\"submit\" value=\"Add Phone\">\r\n *   </form>\r\n *   <h1>Phones</h1>\r\n *   <ul>\r\n *     <li ng-repeat=\"phone in $ctrl.phones\">{{phone.name}}</li>\r\n *   </ul>\r\n *   </div>\r\n * </file>\r\n * </example>\r\n *\r\n *\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#when\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition.\r\n *\r\n * @param {string} method HTTP method.\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp)=} data HTTP request body.\r\n * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\r\n *   object and returns true if the headers match the current definition.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n *\r\n *  - respond \r\n *    ```\r\n *    { function([status,] data[, headers, statusText])\r\n *    | function(function(method, url, data, headers, params)}\r\n *    ```\r\n *     The respond method takes a set of static data to be returned or a function that can return\r\n *    an array containing response status (number), response data (Array|Object|string), response\r\n *    headers (Object), and the text for the status (string).\r\n *  - passThrough  `{function()}`  Any request matching a backend definition with\r\n *    `passThrough` handler will be passed through to the real backend (an XHR request will be made\r\n *    to the server.)\r\n *  - Both methods return the `requestHandler` object for possible overrides.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenGET\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for GET requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenHEAD\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for HEAD requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenDELETE\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for DELETE requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenPOST\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for POST requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp)=} data HTTP request body.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenPUT\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for PUT requests.  For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp)=} data HTTP request body.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenPATCH\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for PATCH requests.  For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(string|RegExp)=} data HTTP request body.\r\n * @param {(Object|function(Object))=} headers HTTP headers.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenJSONP\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition for JSONP requests. For more info see `when()`.\r\n *\r\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\r\n *   and returns true if the url matches the current definition.\r\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\r\n *   {@link ngMock.$httpBackend $httpBackend mock}.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\n/**\r\n * @ngdoc method\r\n * @name $httpBackend#whenRoute\r\n * @module ngMockE2E\r\n * @description\r\n * Creates a new backend definition that compares only with the requested route.\r\n *\r\n * @param {string} method HTTP method.\r\n * @param {string} url HTTP url string that supports colon param matching.\r\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\r\n *   control how a matched request is handled. You can save this object for later use and invoke\r\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\r\n */\r\nangular.mock.e2e = {};\r\nangular.mock.e2e.$httpBackendDecorator =\r\n  ['$rootScope', '$timeout', '$delegate', '$browser', createHttpBackendMock];\r\n\r\n\r\n/**\r\n * @ngdoc type\r\n * @name $rootScope.Scope\r\n * @module ngMock\r\n * @description\r\n * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These\r\n * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when\r\n * `ngMock` module is loaded.\r\n *\r\n * In addition to all the regular `Scope` methods, the following helper methods are available:\r\n */\r\nangular.mock.$RootScopeDecorator = ['$delegate', function($delegate) {\r\n\r\n  var $rootScopePrototype = Object.getPrototypeOf($delegate);\r\n\r\n  $rootScopePrototype.$countChildScopes = countChildScopes;\r\n  $rootScopePrototype.$countWatchers = countWatchers;\r\n\r\n  return $delegate;\r\n\r\n  // ------------------------------------------------------------------------------------------ //\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $rootScope.Scope#$countChildScopes\r\n   * @module ngMock\r\n   * @description\r\n   * Counts all the direct and indirect child scopes of the current scope.\r\n   *\r\n   * The current scope is excluded from the count. The count includes all isolate child scopes.\r\n   *\r\n   * @returns {number} Total number of child scopes.\r\n   */\r\n  function countChildScopes() {\r\n    // jshint validthis: true\r\n    var count = 0; // exclude the current scope\r\n    var pendingChildHeads = [this.$$childHead];\r\n    var currentScope;\r\n\r\n    while (pendingChildHeads.length) {\r\n      currentScope = pendingChildHeads.shift();\r\n\r\n      while (currentScope) {\r\n        count += 1;\r\n        pendingChildHeads.push(currentScope.$$childHead);\r\n        currentScope = currentScope.$$nextSibling;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n\r\n  /**\r\n   * @ngdoc method\r\n   * @name $rootScope.Scope#$countWatchers\r\n   * @module ngMock\r\n   * @description\r\n   * Counts all the watchers of direct and indirect child scopes of the current scope.\r\n   *\r\n   * The watchers of the current scope are included in the count and so are all the watchers of\r\n   * isolate child scopes.\r\n   *\r\n   * @returns {number} Total number of watchers.\r\n   */\r\n  function countWatchers() {\r\n    // jshint validthis: true\r\n    var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope\r\n    var pendingChildHeads = [this.$$childHead];\r\n    var currentScope;\r\n\r\n    while (pendingChildHeads.length) {\r\n      currentScope = pendingChildHeads.shift();\r\n\r\n      while (currentScope) {\r\n        count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;\r\n        pendingChildHeads.push(currentScope.$$childHead);\r\n        currentScope = currentScope.$$nextSibling;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n}];\r\n\r\n\r\n!(function(jasmineOrMocha) {\r\n\r\n  if (!jasmineOrMocha) {\r\n    return;\r\n  }\r\n\r\n  var currentSpec = null,\r\n      injectorState = new InjectorState(),\r\n      annotatedFunctions = [],\r\n      wasInjectorCreated = function() {\r\n        return !!currentSpec;\r\n      };\r\n\r\n  angular.mock.$$annotate = angular.injector.$$annotate;\r\n  angular.injector.$$annotate = function(fn) {\r\n    if (typeof fn === 'function' && !fn.$inject) {\r\n      annotatedFunctions.push(fn);\r\n    }\r\n    return angular.mock.$$annotate.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name angular.mock.module\r\n   * @description\r\n   *\r\n   * *NOTE*: This function is also published on window for easy access.<br>\r\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\r\n   *\r\n   * This function registers a module configuration code. It collects the configuration information\r\n   * which will be used when the injector is created by {@link angular.mock.inject inject}.\r\n   *\r\n   * See {@link angular.mock.inject inject} for usage example\r\n   *\r\n   * @param {...(string|Function|Object)} fns any number of modules which are represented as string\r\n   *        aliases or as anonymous module initialization functions. The modules are used to\r\n   *        configure the injector. The 'ng' and 'ngMock' modules are automatically loaded. If an\r\n   *        object literal is passed each key-value pair will be registered on the module via\r\n   *        {@link auto.$provide $provide}.value, the key being the string name (or token) to associate\r\n   *        with the value on the injector.\r\n   */\r\n  var module = window.module = angular.mock.module = function() {\r\n    var moduleFns = Array.prototype.slice.call(arguments, 0);\r\n    return wasInjectorCreated() ? workFn() : workFn;\r\n    /////////////////////\r\n    function workFn() {\r\n      if (currentSpec.$injector) {\r\n        throw new Error('Injector already created, can not register a module!');\r\n      } else {\r\n        var fn, modules = currentSpec.$modules || (currentSpec.$modules = []);\r\n        angular.forEach(moduleFns, function(module) {\r\n          if (angular.isObject(module) && !angular.isArray(module)) {\r\n            fn = ['$provide', function($provide) {\r\n              angular.forEach(module, function(value, key) {\r\n                $provide.value(key, value);\r\n              });\r\n            }];\r\n          } else {\r\n            fn = module;\r\n          }\r\n          if (currentSpec.$providerInjector) {\r\n            currentSpec.$providerInjector.invoke(fn);\r\n          } else {\r\n            modules.push(fn);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  module.$$beforeAllHook = (window.before || window.beforeAll);\r\n  module.$$afterAllHook = (window.after || window.afterAll);\r\n\r\n  // purely for testing ngMock itself\r\n  module.$$currentSpec = function(to) {\r\n    if (arguments.length === 0) return to;\r\n    currentSpec = to;\r\n  };\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name angular.mock.module.sharedInjector\r\n   * @description\r\n   *\r\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\r\n   *\r\n   * This function ensures a single injector will be used for all tests in a given describe context.\r\n   * This contrasts with the default behaviour where a new injector is created per test case.\r\n   *\r\n   * Use sharedInjector when you want to take advantage of Jasmine's `beforeAll()`, or mocha's\r\n   * `before()` methods. Call `module.sharedInjector()` before you setup any other hooks that\r\n   * will create (i.e call `module()`) or use (i.e call `inject()`) the injector.\r\n   *\r\n   * You cannot call `sharedInjector()` from within a context already using `sharedInjector()`.\r\n   *\r\n   * ##Example\r\n   *\r\n   * Typically beforeAll is used to make many assertions about a single operation. This can\r\n   * cut down test run-time as the test setup doesn't need to be re-run, and enabling focussed\r\n   * tests each with a single assertion.\r\n   *\r\n   * ```js\r\n   * describe(\"Deep Thought\", function() {\r\n   *\r\n   *   module.sharedInjector();\r\n   *\r\n   *   beforeAll(module(\"UltimateQuestion\"));\r\n   *\r\n   *   beforeAll(inject(function(DeepThought) {\r\n   *     expect(DeepThought.answer).toBeUndefined();\r\n   *     DeepThought.generateAnswer();\r\n   *   }));\r\n   *\r\n   *   it(\"has calculated the answer correctly\", inject(function(DeepThought) {\r\n   *     // Because of sharedInjector, we have access to the instance of the DeepThought service\r\n   *     // that was provided to the beforeAll() hook. Therefore we can test the generated answer\r\n   *     expect(DeepThought.answer).toBe(42);\r\n   *   }));\r\n   *\r\n   *   it(\"has calculated the answer within the expected time\", inject(function(DeepThought) {\r\n   *     expect(DeepThought.runTimeMillennia).toBeLessThan(8000);\r\n   *   }));\r\n   *\r\n   *   it(\"has double checked the answer\", inject(function(DeepThought) {\r\n   *     expect(DeepThought.absolutelySureItIsTheRightAnswer).toBe(true);\r\n   *   }));\r\n   *\r\n   * });\r\n   *\r\n   * ```\r\n   */\r\n  module.sharedInjector = function() {\r\n    if (!(module.$$beforeAllHook && module.$$afterAllHook)) {\r\n      throw Error(\"sharedInjector() cannot be used unless your test runner defines beforeAll/afterAll\");\r\n    }\r\n\r\n    var initialized = false;\r\n\r\n    module.$$beforeAllHook(function() {\r\n      if (injectorState.shared) {\r\n        injectorState.sharedError = Error(\"sharedInjector() cannot be called inside a context that has already called sharedInjector()\");\r\n        throw injectorState.sharedError;\r\n      }\r\n      initialized = true;\r\n      currentSpec = this;\r\n      injectorState.shared = true;\r\n    });\r\n\r\n    module.$$afterAllHook(function() {\r\n      if (initialized) {\r\n        injectorState = new InjectorState();\r\n        module.$$cleanup();\r\n      } else {\r\n        injectorState.sharedError = null;\r\n      }\r\n    });\r\n  };\r\n\r\n  module.$$beforeEach = function() {\r\n    if (injectorState.shared && currentSpec && currentSpec != this) {\r\n      var state = currentSpec;\r\n      currentSpec = this;\r\n      angular.forEach([\"$injector\",\"$modules\",\"$providerInjector\", \"$injectorStrict\"], function(k) {\r\n        currentSpec[k] = state[k];\r\n        state[k] = null;\r\n      });\r\n    } else {\r\n      currentSpec = this;\r\n      originalRootElement = null;\r\n      annotatedFunctions = [];\r\n    }\r\n  };\r\n\r\n  module.$$afterEach = function() {\r\n    if (injectorState.cleanupAfterEach()) {\r\n      module.$$cleanup();\r\n    }\r\n  };\r\n\r\n  module.$$cleanup = function() {\r\n    var injector = currentSpec.$injector;\r\n\r\n    annotatedFunctions.forEach(function(fn) {\r\n      delete fn.$inject;\r\n    });\r\n\r\n    angular.forEach(currentSpec.$modules, function(module) {\r\n      if (module && module.$$hashKey) {\r\n        module.$$hashKey = undefined;\r\n      }\r\n    });\r\n\r\n    currentSpec.$injector = null;\r\n    currentSpec.$modules = null;\r\n    currentSpec.$providerInjector = null;\r\n    currentSpec = null;\r\n\r\n    if (injector) {\r\n      // Ensure `$rootElement` is instantiated, before checking `originalRootElement`\r\n      var $rootElement = injector.get('$rootElement');\r\n      var rootNode = $rootElement && $rootElement[0];\r\n      var cleanUpNodes = !originalRootElement ? [] : [originalRootElement[0]];\r\n      if (rootNode && (!originalRootElement || rootNode !== originalRootElement[0])) {\r\n        cleanUpNodes.push(rootNode);\r\n      }\r\n      angular.element.cleanData(cleanUpNodes);\r\n\r\n      // Ensure `$destroy()` is available, before calling it\r\n      // (a mocked `$rootScope` might not implement it (or not even be an object at all))\r\n      var $rootScope = injector.get('$rootScope');\r\n      if ($rootScope && $rootScope.$destroy) $rootScope.$destroy();\r\n    }\r\n\r\n    // clean up jquery's fragment cache\r\n    angular.forEach(angular.element.fragments, function(val, key) {\r\n      delete angular.element.fragments[key];\r\n    });\r\n\r\n    MockXhr.$$lastInstance = null;\r\n\r\n    angular.forEach(angular.callbacks, function(val, key) {\r\n      delete angular.callbacks[key];\r\n    });\r\n    angular.callbacks.$$counter = 0;\r\n  };\r\n\r\n  (window.beforeEach || window.setup)(module.$$beforeEach);\r\n  (window.afterEach || window.teardown)(module.$$afterEach);\r\n\r\n  /**\r\n   * @ngdoc function\r\n   * @name angular.mock.inject\r\n   * @description\r\n   *\r\n   * *NOTE*: This function is also published on window for easy access.<br>\r\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\r\n   *\r\n   * The inject function wraps a function into an injectable function. The inject() creates new\r\n   * instance of {@link auto.$injector $injector} per test, which is then used for\r\n   * resolving references.\r\n   *\r\n   *\r\n   * ## Resolving References (Underscore Wrapping)\r\n   * Often, we would like to inject a reference once, in a `beforeEach()` block and reuse this\r\n   * in multiple `it()` clauses. To be able to do this we must assign the reference to a variable\r\n   * that is declared in the scope of the `describe()` block. Since we would, most likely, want\r\n   * the variable to have the same name of the reference we have a problem, since the parameter\r\n   * to the `inject()` function would hide the outer variable.\r\n   *\r\n   * To help with this, the injected parameters can, optionally, be enclosed with underscores.\r\n   * These are ignored by the injector when the reference name is resolved.\r\n   *\r\n   * For example, the parameter `_myService_` would be resolved as the reference `myService`.\r\n   * Since it is available in the function body as _myService_, we can then assign it to a variable\r\n   * defined in an outer scope.\r\n   *\r\n   * ```\r\n   * // Defined out reference variable outside\r\n   * var myService;\r\n   *\r\n   * // Wrap the parameter in underscores\r\n   * beforeEach( inject( function(_myService_){\r\n   *   myService = _myService_;\r\n   * }));\r\n   *\r\n   * // Use myService in a series of tests.\r\n   * it('makes use of myService', function() {\r\n   *   myService.doStuff();\r\n   * });\r\n   *\r\n   * ```\r\n   *\r\n   * See also {@link angular.mock.module angular.mock.module}\r\n   *\r\n   * ## Example\r\n   * Example of what a typical jasmine tests looks like with the inject method.\r\n   * ```js\r\n   *\r\n   *   angular.module('myApplicationModule', [])\r\n   *       .value('mode', 'app')\r\n   *       .value('version', 'v1.0.1');\r\n   *\r\n   *\r\n   *   describe('MyApp', function() {\r\n   *\r\n   *     // You need to load modules that you want to test,\r\n   *     // it loads only the \"ng\" module by default.\r\n   *     beforeEach(module('myApplicationModule'));\r\n   *\r\n   *\r\n   *     // inject() is used to inject arguments of all given functions\r\n   *     it('should provide a version', inject(function(mode, version) {\r\n   *       expect(version).toEqual('v1.0.1');\r\n   *       expect(mode).toEqual('app');\r\n   *     }));\r\n   *\r\n   *\r\n   *     // The inject and module method can also be used inside of the it or beforeEach\r\n   *     it('should override a version and test the new version is injected', function() {\r\n   *       // module() takes functions or strings (module aliases)\r\n   *       module(function($provide) {\r\n   *         $provide.value('version', 'overridden'); // override version here\r\n   *       });\r\n   *\r\n   *       inject(function(version) {\r\n   *         expect(version).toEqual('overridden');\r\n   *       });\r\n   *     });\r\n   *   });\r\n   *\r\n   * ```\r\n   *\r\n   * @param {...Function} fns any number of functions which will be injected using the injector.\r\n   */\r\n\r\n\r\n\r\n  var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {\r\n    this.message = e.message;\r\n    this.name = e.name;\r\n    if (e.line) this.line = e.line;\r\n    if (e.sourceId) this.sourceId = e.sourceId;\r\n    if (e.stack && errorForStack)\r\n      this.stack = e.stack + '\\n' + errorForStack.stack;\r\n    if (e.stackArray) this.stackArray = e.stackArray;\r\n  };\r\n  ErrorAddingDeclarationLocationStack.prototype = Error.prototype;\r\n\r\n  window.inject = angular.mock.inject = function() {\r\n    var blockFns = Array.prototype.slice.call(arguments, 0);\r\n    var errorForStack = new Error('Declaration Location');\r\n    // IE10+ and PhanthomJS do not set stack trace information, until the error is thrown\r\n    if (!errorForStack.stack) {\r\n      try {\r\n        throw errorForStack;\r\n      } catch (e) {}\r\n    }\r\n    return wasInjectorCreated() ? workFn.call(currentSpec) : workFn;\r\n    /////////////////////\r\n    function workFn() {\r\n      var modules = currentSpec.$modules || [];\r\n      var strictDi = !!currentSpec.$injectorStrict;\r\n      modules.unshift(['$injector', function($injector) {\r\n        currentSpec.$providerInjector = $injector;\r\n      }]);\r\n      modules.unshift('ngMock');\r\n      modules.unshift('ng');\r\n      var injector = currentSpec.$injector;\r\n      if (!injector) {\r\n        if (strictDi) {\r\n          // If strictDi is enabled, annotate the providerInjector blocks\r\n          angular.forEach(modules, function(moduleFn) {\r\n            if (typeof moduleFn === \"function\") {\r\n              angular.injector.$$annotate(moduleFn);\r\n            }\r\n          });\r\n        }\r\n        injector = currentSpec.$injector = angular.injector(modules, strictDi);\r\n        currentSpec.$injectorStrict = strictDi;\r\n      }\r\n      for (var i = 0, ii = blockFns.length; i < ii; i++) {\r\n        if (currentSpec.$injectorStrict) {\r\n          // If the injector is strict / strictDi, and the spec wants to inject using automatic\r\n          // annotation, then annotate the function here.\r\n          injector.annotate(blockFns[i]);\r\n        }\r\n        try {\r\n          /* jshint -W040 *//* Jasmine explicitly provides a `this` object when calling functions */\r\n          injector.invoke(blockFns[i] || angular.noop, this);\r\n          /* jshint +W040 */\r\n        } catch (e) {\r\n          if (e.stack && errorForStack) {\r\n            throw new ErrorAddingDeclarationLocationStack(e, errorForStack);\r\n          }\r\n          throw e;\r\n        } finally {\r\n          errorForStack = null;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  angular.mock.inject.strictDi = function(value) {\r\n    value = arguments.length ? !!value : true;\r\n    return wasInjectorCreated() ? workFn() : workFn;\r\n\r\n    function workFn() {\r\n      if (value !== currentSpec.$injectorStrict) {\r\n        if (currentSpec.$injector) {\r\n          throw new Error('Injector already created, can not modify strict annotations');\r\n        } else {\r\n          currentSpec.$injectorStrict = value;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  function InjectorState() {\r\n    this.shared = false;\r\n    this.sharedError = null;\r\n\r\n    this.cleanupAfterEach = function() {\r\n      return !this.shared || this.sharedError;\r\n    };\r\n  }\r\n})(window.jasmine || window.mocha);\r\n\r\n\r\n})(window, window.angular);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/angular-mocks/angular-mocks.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = require(\"././angular-mocks.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** angular-mocks (bower component)\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}